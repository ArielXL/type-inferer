============================ LEXER =============================
FILA: 1, COLUMNA: 0, TIPO: class, LEXEMA: class
FILA: 1, COLUMNA: 6, TIPO: type, LEXEMA: Main
FILA: 1, COLUMNA: 11, TIPO: inherits, LEXEMA: inherits
FILA: 1, COLUMNA: 20, TIPO: type, LEXEMA: IO
FILA: 1, COLUMNA: 23, TIPO: {, LEXEMA: {
FILA: 3, COLUMNA: 1, TIPO: id, LEXEMA: main
FILA: 3, COLUMNA: 5, TIPO: (, LEXEMA: (
FILA: 3, COLUMNA: 6, TIPO: ), LEXEMA: )
FILA: 3, COLUMNA: 8, TIPO: :, LEXEMA: :
FILA: 3, COLUMNA: 10, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 3, COLUMNA: 20, TIPO: {, LEXEMA: {
FILA: 4, COLUMNA: 2, TIPO: let, LEXEMA: let
FILA: 4, COLUMNA: 6, TIPO: id, LEXEMA: x
FILA: 4, COLUMNA: 8, TIPO: :, LEXEMA: :
FILA: 4, COLUMNA: 10, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 4, COLUMNA: 20, TIPO: <-, LEXEMA: <-
FILA: 4, COLUMNA: 23, TIPO: integer, LEXEMA: 3
FILA: 4, COLUMNA: 25, TIPO: in, LEXEMA: in
FILA: 4, COLUMNA: 28, TIPO: {, LEXEMA: {
FILA: 5, COLUMNA: 3, TIPO: case, LEXEMA: case
FILA: 5, COLUMNA: 8, TIPO: id, LEXEMA: x
FILA: 5, COLUMNA: 10, TIPO: of, LEXEMA: of
FILA: 6, COLUMNA: 4, TIPO: id, LEXEMA: y
FILA: 6, COLUMNA: 6, TIPO: :, LEXEMA: :
FILA: 6, COLUMNA: 8, TIPO: type, LEXEMA: Int
FILA: 6, COLUMNA: 12, TIPO: =>, LEXEMA: =>
FILA: 6, COLUMNA: 15, TIPO: id, LEXEMA: out_string
FILA: 6, COLUMNA: 25, TIPO: (, LEXEMA: (
FILA: 6, COLUMNA: 26, TIPO: string, LEXEMA: Ok
FILA: 6, COLUMNA: 30, TIPO: ), LEXEMA: )
FILA: 6, COLUMNA: 31, TIPO: ;, LEXEMA: ;
FILA: 7, COLUMNA: 3, TIPO: esac, LEXEMA: esac
FILA: 7, COLUMNA: 7, TIPO: ;, LEXEMA: ;
FILA: 8, COLUMNA: 2, TIPO: }, LEXEMA: }
FILA: 9, COLUMNA: 1, TIPO: }, LEXEMA: }
FILA: 9, COLUMNA: 2, TIPO: ;, LEXEMA: ;
FILA: 10, COLUMNA: 0, TIPO: }, LEXEMA: }
FILA: 10, COLUMNA: 1, TIPO: ;, LEXEMA: ;
FILA: 12, COLUMNA: 0, TIPO: class, LEXEMA: class
FILA: 12, COLUMNA: 6, TIPO: type, LEXEMA: A
FILA: 12, COLUMNA: 8, TIPO: inherits, LEXEMA: inherits
FILA: 12, COLUMNA: 17, TIPO: type, LEXEMA: IO
FILA: 12, COLUMNA: 20, TIPO: {, LEXEMA: {
FILA: 14, COLUMNA: 1, TIPO: id, LEXEMA: x
FILA: 14, COLUMNA: 2, TIPO: :, LEXEMA: :
FILA: 14, COLUMNA: 4, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 14, COLUMNA: 13, TIPO: ;, LEXEMA: ;
FILA: 15, COLUMNA: 1, TIPO: id, LEXEMA: y
FILA: 15, COLUMNA: 2, TIPO: :, LEXEMA: :
FILA: 15, COLUMNA: 4, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 15, COLUMNA: 13, TIPO: ;, LEXEMA: ;
FILA: 17, COLUMNA: 1, TIPO: id, LEXEMA: init
FILA: 17, COLUMNA: 5, TIPO: (, LEXEMA: (
FILA: 17, COLUMNA: 6, TIPO: id, LEXEMA: n
FILA: 17, COLUMNA: 8, TIPO: :, LEXEMA: :
FILA: 17, COLUMNA: 10, TIPO: type, LEXEMA: Int
FILA: 17, COLUMNA: 13, TIPO: ,, LEXEMA: ,
FILA: 17, COLUMNA: 15, TIPO: id, LEXEMA: m
FILA: 17, COLUMNA: 16, TIPO: :, LEXEMA: :
FILA: 17, COLUMNA: 18, TIPO: type, LEXEMA: Int
FILA: 17, COLUMNA: 21, TIPO: ), LEXEMA: )
FILA: 17, COLUMNA: 23, TIPO: :, LEXEMA: :
FILA: 17, COLUMNA: 25, TIPO: type, LEXEMA: SELF_TYPE
FILA: 17, COLUMNA: 35, TIPO: {, LEXEMA: {
FILA: 18, COLUMNA: 2, TIPO: {, LEXEMA: {
FILA: 19, COLUMNA: 3, TIPO: id, LEXEMA: x
FILA: 19, COLUMNA: 5, TIPO: <-, LEXEMA: <-
FILA: 19, COLUMNA: 8, TIPO: id, LEXEMA: n
FILA: 19, COLUMNA: 9, TIPO: ;, LEXEMA: ;
FILA: 20, COLUMNA: 3, TIPO: id, LEXEMA: y
FILA: 20, COLUMNA: 5, TIPO: <-, LEXEMA: <-
FILA: 20, COLUMNA: 8, TIPO: id, LEXEMA: m
FILA: 20, COLUMNA: 9, TIPO: ;, LEXEMA: ;
FILA: 21, COLUMNA: 3, TIPO: id, LEXEMA: self
FILA: 21, COLUMNA: 7, TIPO: ;, LEXEMA: ;
FILA: 22, COLUMNA: 2, TIPO: }, LEXEMA: }
FILA: 23, COLUMNA: 1, TIPO: }, LEXEMA: }
FILA: 23, COLUMNA: 2, TIPO: ;, LEXEMA: ;
FILA: 25, COLUMNA: 1, TIPO: id, LEXEMA: succ
FILA: 25, COLUMNA: 5, TIPO: (, LEXEMA: (
FILA: 25, COLUMNA: 6, TIPO: id, LEXEMA: n
FILA: 25, COLUMNA: 7, TIPO: :, LEXEMA: :
FILA: 25, COLUMNA: 9, TIPO: type, LEXEMA: Int
FILA: 25, COLUMNA: 12, TIPO: ), LEXEMA: )
FILA: 25, COLUMNA: 13, TIPO: :, LEXEMA: :
FILA: 25, COLUMNA: 15, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 25, COLUMNA: 25, TIPO: {, LEXEMA: {
FILA: 25, COLUMNA: 27, TIPO: id, LEXEMA: n
FILA: 25, COLUMNA: 29, TIPO: +, LEXEMA: +
FILA: 25, COLUMNA: 31, TIPO: integer, LEXEMA: 1
FILA: 25, COLUMNA: 33, TIPO: }, LEXEMA: }
FILA: 25, COLUMNA: 34, TIPO: ;, LEXEMA: ;
FILA: 27, COLUMNA: 1, TIPO: id, LEXEMA: succ2
FILA: 27, COLUMNA: 6, TIPO: (, LEXEMA: (
FILA: 27, COLUMNA: 7, TIPO: id, LEXEMA: n
FILA: 27, COLUMNA: 9, TIPO: :, LEXEMA: :
FILA: 27, COLUMNA: 11, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 27, COLUMNA: 20, TIPO: ), LEXEMA: )
FILA: 27, COLUMNA: 22, TIPO: :, LEXEMA: :
FILA: 27, COLUMNA: 24, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 27, COLUMNA: 34, TIPO: {, LEXEMA: {
FILA: 27, COLUMNA: 36, TIPO: id, LEXEMA: n
FILA: 27, COLUMNA: 38, TIPO: +, LEXEMA: +
FILA: 27, COLUMNA: 40, TIPO: integer, LEXEMA: 1
FILA: 27, COLUMNA: 42, TIPO: }, LEXEMA: }
FILA: 27, COLUMNA: 43, TIPO: ;, LEXEMA: ;
FILA: 29, COLUMNA: 1, TIPO: id, LEXEMA: fact
FILA: 29, COLUMNA: 5, TIPO: (, LEXEMA: (
FILA: 29, COLUMNA: 6, TIPO: id, LEXEMA: n
FILA: 29, COLUMNA: 7, TIPO: :, LEXEMA: :
FILA: 29, COLUMNA: 9, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 29, COLUMNA: 18, TIPO: ), LEXEMA: )
FILA: 29, COLUMNA: 20, TIPO: :, LEXEMA: :
FILA: 29, COLUMNA: 22, TIPO: type, LEXEMA: AUTO_TYPE
FILA: 29, COLUMNA: 32, TIPO: {, LEXEMA: {
FILA: 30, COLUMNA: 2, TIPO: if, LEXEMA: if
FILA: 30, COLUMNA: 5, TIPO: (, LEXEMA: (
FILA: 30, COLUMNA: 6, TIPO: id, LEXEMA: n
FILA: 30, COLUMNA: 8, TIPO: <, LEXEMA: <
FILA: 30, COLUMNA: 10, TIPO: integer, LEXEMA: 0
FILA: 30, COLUMNA: 11, TIPO: ), LEXEMA: )
FILA: 30, COLUMNA: 13, TIPO: then, LEXEMA: then
FILA: 30, COLUMNA: 18, TIPO: integer, LEXEMA: 1
FILA: 30, COLUMNA: 20, TIPO: else, LEXEMA: else
FILA: 30, COLUMNA: 25, TIPO: id, LEXEMA: n
FILA: 30, COLUMNA: 27, TIPO: *, LEXEMA: *
FILA: 30, COLUMNA: 29, TIPO: id, LEXEMA: fact
FILA: 30, COLUMNA: 33, TIPO: (, LEXEMA: (
FILA: 30, COLUMNA: 34, TIPO: id, LEXEMA: n
FILA: 30, COLUMNA: 36, TIPO: -, LEXEMA: -
FILA: 30, COLUMNA: 38, TIPO: integer, LEXEMA: 1
FILA: 30, COLUMNA: 39, TIPO: ), LEXEMA: )
FILA: 30, COLUMNA: 41, TIPO: fi, LEXEMA: fi
FILA: 31, COLUMNA: 1, TIPO: }, LEXEMA: }
FILA: 31, COLUMNA: 2, TIPO: ;, LEXEMA: ;
FILA: 32, COLUMNA: 0, TIPO: }, LEXEMA: }
FILA: 32, COLUMNA: 1, TIPO: ;, LEXEMA: ;
FILA: 0, COLUMNA: 0, TIPO: $, LEXEMA: $
============================ PARSER ============================
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<let-list> -> id : type <- <expr>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<atom> -> string
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<arg-list> -> <expr>
<member-call> -> id ( <arg-list> )
<atom> -> <member-call>
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<case-list> -> id : type => <expr> ;
<expr> -> case <expr> of <case-list> esac
<expr-list> -> <expr> ;
<expr> -> { <expr-list> }
<expr> -> let <let-list> in <expr>
<feature> -> id ( ) : type { <expr> } ;
<feature-list> -> ε
<feature-list> -> <feature> <feature-list>
<def-class> -> class type inherits type { <feature-list> } ;
<feature> -> id : type ;
<feature> -> id : type ;
<param> -> id : type
<param> -> id : type
<param-list> -> <param>
<param-list> -> <param> , <param-list>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<expr> -> id <- <expr>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<expr> -> id <- <expr>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<expr-list> -> <expr> ;
<expr-list> -> <expr> ; <expr-list>
<expr-list> -> <expr> ; <expr-list>
<expr> -> { <expr-list> }
<feature> -> id ( <param-list> ) : type { <expr> } ;
<param> -> id : type
<param-list> -> <param>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <arith> + <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<feature> -> id ( <param-list> ) : type { <expr> } ;
<param> -> id : type
<param-list> -> <param>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <arith> + <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<feature> -> id ( <param-list> ) : type { <expr> } ;
<param> -> id : type
<param-list> -> <param>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <comp-expr> < <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<atom> -> ( <expr> )
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<atom> -> id
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <term>
<atom> -> integer
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <factor>
<arith> -> <arith> - <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<arg-list> -> <expr>
<member-call> -> id ( <arg-list> )
<atom> -> <member-call>
<factor-2> -> <atom>
<factor> -> <factor-2>
<term> -> <term> * <factor>
<arith> -> <term>
<comp-expr> -> <arith>
<truth-expr> -> <comp-expr>
<expr> -> <truth-expr>
<expr> -> if <expr> then <expr> else <expr> fi
<feature> -> id ( <param-list> ) : type { <expr> } ;
<feature-list> -> ε
<feature-list> -> <feature> <feature-list>
<feature-list> -> <feature> <feature-list>
<feature-list> -> <feature> <feature-list>
<feature-list> -> <feature> <feature-list>
<feature-list> -> <feature> <feature-list>
<feature-list> -> <feature> <feature-list>
<def-class> -> class type inherits type { <feature-list> } ;
<class-list> -> <def-class>
<class-list> -> <def-class> <class-list>
<program> -> <class-list>
============================= AST ==============================
\__ProgramNode [<class> ... <class>]
    \__ClassDeclarationNode : class Main inherits IO { <feature> ... <feature> }
        \__FuncDeclarationNode : main() : AUTO_TYPE { <expr> }
            \__LetInNode : let x : AUTO_TYPE <- <expr> in <expr>
                \__IntegerNode : 3
                \__BlockNode : { <expr>; ... <expr>; }
                    \__CaseOfNode : case <expr> of y : Int => <expr>; esac
                        \__IdNode : x
                        \__MemberCallNode : out_string(<expr>, ..., <expr>)
                            \__StringNode : Ok
    \__ClassDeclarationNode : class A inherits IO { <feature> ... <feature> }
        \__AttrDeclarationNode : x : AUTO_TYPE;
        \__AttrDeclarationNode : y : AUTO_TYPE;
        \__FuncDeclarationNode : init(n : Int, m : Int) : SELF_TYPE { <expr> }
            \__BlockNode : { <expr>; ... <expr>; }
                \__AssingNode : x <- <expr>
                    \__IdNode : n
                \__AssingNode : y <- <expr>
                    \__IdNode : m
                \__IdNode : self
        \__FuncDeclarationNode : succ(n : Int) : AUTO_TYPE { <expr> }
            \__<expr> PlusNode <expr>
                \__IdNode : n
                \__IntegerNode : 1
        \__FuncDeclarationNode : succ2(n : AUTO_TYPE) : AUTO_TYPE { <expr> }
            \__<expr> PlusNode <expr>
                \__IdNode : n
                \__IntegerNode : 1
        \__FuncDeclarationNode : fact(n : AUTO_TYPE) : AUTO_TYPE { <expr> }
            \__IfThenElseNode : if <expr> then <expr> else <expr> fi
                \__<expr> LessNode <expr>
                    \__IdNode : n
                    \__IntegerNode : 0
                \__IntegerNode : 1
                \__<expr> StarNode <expr>
                    \__IdNode : n
                    \__MemberCallNode : fact(<expr>, ..., <expr>)
                        \__<expr> MinusNode <expr>
                            \__IdNode : n
                            \__IntegerNode : 1
======================= COLECCIONANDO TIPOS ========================
ERRORES : [
]
CONTEXTO :
{
    tipo SELF_TYPE {}
    
    tipo AUTO_TYPE {}
    
    tipo Object {}
    
    tipo IO {}
    
    tipo Int {}
    
    tipo String {}
    
    tipo Bool {}
    
    tipo Main {}
    
    tipo A {}
    
}
======================= CONSTRUYENDO TIPOS ========================
ERRORES : [
]
CONTEXTO :
{
    tipo SELF_TYPE {}
    
    tipo AUTO_TYPE {}
    
    tipo Object {
        [method] abort() : Object ;
        [method] type_name() : String ;
        [method] copy() : SELF_TYPE ;
    }
    
    tipo IO : Object {
        [method] out_string(s : String) : SELF_TYPE ;
        [method] out_int(i : Int) : SELF_TYPE ;
        [method] in_string() : String ;
        [method] in_int() : Int ;
    }
    
    tipo Int : Object {}
    
    tipo String : Object {
        [method] length() : Int ;
        [method] concat(s : String) : String ;
        [method] substr(pos : Int, len : Int) : String ;
    }
    
    tipo Bool : Object {}
    
    tipo Main : IO {
        [method] main() : AUTO_TYPE ;
    }
    
    tipo A : IO {
        [attribute] x : AUTO_TYPE ;
        [attribute] y : AUTO_TYPE ;
        [method] init(n : Int, m : Int) : SELF_TYPE ;
        [method] succ(n : Int) : AUTO_TYPE ;
        [method] succ2(n : AUTO_TYPE) : AUTO_TYPE ;
        [method] fact(n : AUTO_TYPE) : AUTO_TYPE ;
    }
    
}
======================== CHEQUEANDO TIPOS =========================
ERRORES : [
]
CONTEXTO :
{
    tipo SELF_TYPE {}
    
    tipo AUTO_TYPE {}
    
    tipo Object {
        [method] abort() : Object ;
        [method] type_name() : String ;
        [method] copy() : SELF_TYPE ;
    }
    
    tipo IO : Object {
        [method] out_string(s : String) : SELF_TYPE ;
        [method] out_int(i : Int) : SELF_TYPE ;
        [method] in_string() : String ;
        [method] in_int() : Int ;
    }
    
    tipo Int : Object {}
    
    tipo String : Object {
        [method] length() : Int ;
        [method] concat(s : String) : String ;
        [method] substr(pos : Int, len : Int) : String ;
    }
    
    tipo Bool : Object {}
    
    tipo Main : IO {
        [method] main() : AUTO_TYPE ;
    }
    
    tipo A : IO {
        [attribute] x : AUTO_TYPE ;
        [attribute] y : AUTO_TYPE ;
        [method] init(n : Int, m : Int) : SELF_TYPE ;
        [method] succ(n : Int) : AUTO_TYPE ;
        [method] succ2(n : AUTO_TYPE) : AUTO_TYPE ;
        [method] fact(n : AUTO_TYPE) : AUTO_TYPE ;
    }
    
}
======================== INFERENCIA DE TIPOS ========================
INFERENCIA : [
    LINEA 4 , COLUMNA 6 : LA VARIABLE "x" POSEE TIPO "Int".
    EL METODO "main" DE LA CLASE "Main" POSEE COMO TIPO DE RETORNO "Main".
    EL METODO "succ" DE LA CLASE "A" POSEE COMO TIPO DE RETORNO "Int".
    EL PARAMETRO "n", EN EL METODO "succ2" Y EN LA CLASE "A" POSEE TIPO "Int".
    EL METODO "succ2" DE LA CLASE "A" POSEE COMO TIPO DE RETORNO "Int".
    EL PARAMETRO "n", EN EL METODO "fact" Y EN LA CLASE "A" POSEE TIPO "Int".
    EL METODO "fact" DE LA CLASE "A" POSEE COMO TIPO DE RETORNO "Int".
    EL ATRIBUTO "x" DE LA CLASE "A" POSEE TIPO "Int".
    EL ATRIBUTO "y" DE LA CLASE "A" POSEE TIPO "Int".
]
CONTEXTO :
{
    tipo SELF_TYPE {}
    
    tipo AUTO_TYPE {}
    
    tipo Object {
        [method] abort() : Object ;
        [method] type_name() : String ;
        [method] copy() : SELF_TYPE ;
    }
    
    tipo IO : Object {
        [method] out_string(s : String) : SELF_TYPE ;
        [method] out_int(i : Int) : SELF_TYPE ;
        [method] in_string() : String ;
        [method] in_int() : Int ;
    }
    
    tipo Int : Object {}
    
    tipo String : Object {
        [method] length() : Int ;
        [method] concat(s : String) : String ;
        [method] substr(pos : Int, len : Int) : String ;
    }
    
    tipo Bool : Object {}
    
    tipo Main : IO {
        [method] main() : Main ;
    }
    
    tipo A : IO {
        [attribute] x : Int ;
        [attribute] y : Int ;
        [method] init(n : Int, m : Int) : SELF_TYPE ;
        [method] succ(n : Int) : Int ;
        [method] succ2(n : Int) : Int ;
        [method] fact(n : Int) : Int ;
    }
    
}